# syntax=docker/dockerfile:1
# Self-contained Dockerfile for zenova-agents orchestrator
# No build context required - all source is embedded inline
# Build: docker build -f Dockerfile.standalone -t zenova-orchestrator .
# Run:   docker run -p 4000:4000 zenova-orchestrator

FROM node:22-slim

WORKDIR /app

# ============================================================
# 1. Write all source files
# ============================================================

# -- package.json --
RUN cat << 'EOF' > /app/package.json
{
  "name": "@zenova/orchestrator",
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "vitest"
  },
  "dependencies": {
    "@hono/node-server": "^1.13.0",
    "hono": "^4.7.0",
    "dockerode": "^4.0.0",
    "ioredis": "^5.4.0",
    "yaml": "^2.7.0"
  },
  "devDependencies": {
    "@types/dockerode": "^3.3.0",
    "@types/node": "^22.0.0",
    "tsx": "^4.19.0",
    "typescript": "^5.7.0",
    "vitest": "^3.0.0"
  }
}
EOF

# -- tsconfig.json --
RUN cat << 'EOF' > /app/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "declaration": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
EOF

# -- src directory --
RUN mkdir -p /app/src /app/config

# -- src/types.ts --
RUN cat << 'EOF' > /app/src/types.ts
export interface PlaneWebhookPayload {
  event: string
  action: string
  data: {
    id: string
    name: string
    description_html?: string
    description_stripped?: string
    priority: 'urgent' | 'high' | 'medium' | 'low' | 'none'
    state: { name: string; group: string }
    assignees: string[]
    labels: Array<{ id: string; name: string }>
    project: string
    workspace: string
  }
}

export interface AgentConfig {
  name: string
  assigneeId: string
  dockerImage: string
  tools: string[]
  timeout: number
  maxConcurrency: number
  promptFile: string
}

export interface QueuedTask {
  id: string
  issueId: string
  projectId: string
  workspaceSlug: string
  agentType: string
  priority: number
  payload: PlaneWebhookPayload['data']
  queuedAt: string
}

export interface RunningAgent {
  taskId: string
  containerId: string
  agentType: string
  issueId: string
  startedAt: string
}
EOF

# -- src/router.ts --
RUN cat << 'EOF' > /app/src/router.ts
import type { AgentConfig } from './types.js'

export class AgentRouter {
  private byAssignee: Map<string, AgentConfig>
  private byLabel: Map<string, AgentConfig>

  constructor(private agents: AgentConfig[]) {
    this.byAssignee = new Map(agents.map((a) => [a.assigneeId, a]))
    this.byLabel = new Map(agents.map((a) => [a.name, a]))
  }

  routeByAssignee(assigneeId: string): AgentConfig | undefined {
    return this.byAssignee.get(assigneeId)
  }

  routeByLabel(labelName: string): AgentConfig | undefined {
    return this.byLabel.get(labelName.toLowerCase())
  }

  resolve(issue: { assignees: string[]; labels: Array<{ id: string; name: string }> }): AgentConfig | undefined {
    for (const assigneeId of issue.assignees) {
      const config = this.routeByAssignee(assigneeId)
      if (config) return config
    }
    for (const label of issue.labels) {
      const config = this.routeByLabel(label.name)
      if (config) return config
    }
    return undefined
  }
}
EOF

# -- src/config.ts --
RUN cat << 'EOF' > /app/src/config.ts
import { readFileSync } from 'fs'
import { parse } from 'yaml'
import { AgentRouter } from './router.js'
import type { AgentConfig, PlaneWebhookPayload } from './types.js'

export function loadAgentConfigs(configPath: string): AgentConfig[] {
  const raw = readFileSync(configPath, 'utf-8')
  const parsed = parse(raw)
  return parsed.agents as AgentConfig[]
}

const PRIORITY_MAP: Record<string, number> = { urgent: 0, high: 1, medium: 2, low: 3, none: 4 }

export class Dispatcher {
  private router: AgentRouter
  constructor(private agents: AgentConfig[]) { this.router = new AgentRouter(agents) }

  shouldDispatch(payload: PlaneWebhookPayload): { agentConfig: AgentConfig; priority: number } | null {
    if (payload.event !== 'issue') return null
    const agentConfig = this.router.resolve({ assignees: payload.data.assignees, labels: payload.data.labels })
    if (!agentConfig) return null
    return { agentConfig, priority: PRIORITY_MAP[payload.data.priority] ?? 2 }
  }
}
EOF

# -- src/queue.ts --
RUN cat << 'EOF' > /app/src/queue.ts
import type { Redis } from 'ioredis'
import type { QueuedTask } from './types.js'

const QUEUE_KEY = 'zenova:task-queue'
const TASK_PREFIX = 'zenova:task:'

export class TaskQueue {
  constructor(private redis: Redis) {}

  async enqueue(task: QueuedTask): Promise<void> {
    await this.redis.set(`${TASK_PREFIX}${task.id}`, JSON.stringify(task))
    await this.redis.zadd(QUEUE_KEY, task.priority, task.id)
  }

  async dequeue(): Promise<QueuedTask | null> {
    const result = await this.redis.zpopmin(QUEUE_KEY)
    if (!result || result.length === 0) return null
    const taskId = result[0] as string
    const data = await this.redis.get(`${TASK_PREFIX}${taskId}`)
    if (!data) return null
    await this.redis.del(`${TASK_PREFIX}${taskId}`)
    return JSON.parse(data)
  }

  async depth(): Promise<number> {
    return this.redis.zcard(QUEUE_KEY)
  }

  async peek(count = 10): Promise<string[]> {
    return this.redis.zrange(QUEUE_KEY, 0, count - 1)
  }
}
EOF

# -- src/plane-client.ts --
RUN cat << 'EOF' > /app/src/plane-client.ts
export class PlaneClient {
  constructor(
    private baseUrl: string,
    private apiToken: string
  ) {}

  private headers() {
    return {
      'Content-Type': 'application/json',
      'X-API-Key': this.apiToken,
    }
  }

  private url(path: string) {
    return `${this.baseUrl}${path}`
  }

  async getIssue(workspaceSlug: string, projectId: string, issueId: string) {
    const res = await fetch(
      this.url(`/api/v1/workspaces/${workspaceSlug}/projects/${projectId}/issues/${issueId}/`),
      { headers: this.headers() }
    )
    if (!res.ok) throw new Error(`Failed to get issue: ${res.status}`)
    return res.json()
  }

  async updateIssueState(workspaceSlug: string, projectId: string, issueId: string, stateId: string) {
    const res = await fetch(
      this.url(`/api/v1/workspaces/${workspaceSlug}/projects/${projectId}/issues/${issueId}/`),
      {
        method: 'PATCH',
        headers: this.headers(),
        body: JSON.stringify({ state: stateId }),
      }
    )
    if (!res.ok) throw new Error(`Failed to update issue state: ${res.status}`)
    return res.json()
  }

  async addComment(workspaceSlug: string, projectId: string, issueId: string, comment: string) {
    const res = await fetch(
      this.url(`/api/v1/workspaces/${workspaceSlug}/projects/${projectId}/issues/${issueId}/comments/`),
      {
        method: 'POST',
        headers: this.headers(),
        body: JSON.stringify({ comment_html: `<p>${comment}</p>` }),
      }
    )
    if (!res.ok) throw new Error(`Failed to add comment: ${res.status}`)
    return res.json()
  }

  async addIssueLink(workspaceSlug: string, projectId: string, issueId: string, url: string, title: string) {
    const res = await fetch(
      this.url(`/api/v1/workspaces/${workspaceSlug}/projects/${projectId}/issues/${issueId}/links/`),
      {
        method: 'POST',
        headers: this.headers(),
        body: JSON.stringify({ url, title }),
      }
    )
    if (!res.ok) throw new Error(`Failed to add link: ${res.status}`)
    return res.json()
  }

  async getProjectStates(workspaceSlug: string, projectId: string) {
    const res = await fetch(
      this.url(`/api/v1/workspaces/${workspaceSlug}/projects/${projectId}/states/`),
      { headers: this.headers() }
    )
    if (!res.ok) throw new Error(`Failed to get states: ${res.status}`)
    return res.json()
  }
}
EOF

# -- src/docker.ts --
RUN cat << 'EOF' > /app/src/docker.ts
import type Dockerode from 'dockerode'
import type { AgentConfig, QueuedTask, RunningAgent } from './types.js'

export type OnAgentComplete = (taskId: string, agentType: string) => void

export class ContainerManager {
  private running = new Map<string, RunningAgent>()
  private onComplete: OnAgentComplete | null = null

  constructor(private docker: Dockerode) {}

  setOnComplete(callback: OnAgentComplete): void {
    this.onComplete = callback
  }

  async runAgent(agent: AgentConfig, task: QueuedTask, secrets: Record<string, string>): Promise<string> {
    const containerName = `zenova-agent-${agent.name}-${task.id}-${Date.now()}`
    const env = [
      `TASK_ID=${task.id}`,
      `ISSUE_ID=${task.issueId}`,
      `PROJECT_ID=${task.projectId}`,
      `WORKSPACE_SLUG=${task.workspaceSlug}`,
      `ISSUE_TITLE=${task.payload.name || ''}`,
      `ISSUE_DESCRIPTION=${task.payload.description_stripped || ''}`,
      `AGENT_TYPE=${agent.name}`,
      ...Object.entries(secrets).map(([k, v]) => `${k}=${v}`),
    ]
    const container = await this.docker.createContainer({
      Image: agent.dockerImage,
      name: containerName,
      Env: env,
      HostConfig: {
        Memory: 2 * 1024 * 1024 * 1024,
        NanoCpus: 2 * 1e9,
        AutoRemove: false,
      },
    })
    await container.start()
    this.running.set(task.id, {
      taskId: task.id, containerId: container.id, agentType: agent.name,
      issueId: task.issueId, startedAt: new Date().toISOString(),
    })

    // Wait for container to finish, then drain queue
    container.wait().then(async () => {
      this.running.delete(task.id)
      try { await container.remove() } catch {}
      if (this.onComplete) this.onComplete(task.id, agent.name)
    }).catch(() => {
      this.running.delete(task.id)
    })

    // Safety timeout
    setTimeout(async () => {
      if (this.running.has(task.id)) {
        try {
          const c = this.docker.getContainer(container.id)
          await c.stop({ t: 10 })
          await c.remove()
        } catch {}
        this.running.delete(task.id)
      }
    }, agent.timeout * 1000)

    return container.id
  }

  getRunningCount(agentType: string): number {
    return [...this.running.values()].filter(r => r.agentType === agentType).length
  }

  getRunning(): RunningAgent[] { return [...this.running.values()] }
  markCompleted(taskId: string): void { this.running.delete(taskId) }
}
EOF

# -- src/index.ts --
# NOTE: This file contains backticks and ${} in template literals.
# Using quoted heredoc ('INDEXEOF') preserves them literally.
RUN cat << 'INDEXEOF' > /app/src/index.ts
import { Hono } from 'hono'
import { logger } from 'hono/logger'
import { randomUUID, createHmac, timingSafeEqual } from 'crypto'
import type { PlaneWebhookPayload, QueuedTask } from './types.js'
import { Dispatcher } from './config.js'
import { TaskQueue } from './queue.js'
import { ContainerManager } from './docker.js'
import { PlaneClient } from './plane-client.js'

export const app = new Hono()
app.use('*', logger())

let dispatcher: Dispatcher | null = null
let queue: TaskQueue | null = null
let containers: ContainerManager | null = null
let plane: PlaneClient | null = null
let webhookSecret: string | null = null
let redisClient: any = null

export function init(deps: {
  dispatcher: Dispatcher
  queue: TaskQueue
  containers: ContainerManager
  plane: PlaneClient
  webhookSecret?: string
  redis?: any
}) {
  dispatcher = deps.dispatcher
  queue = deps.queue
  containers = deps.containers
  plane = deps.plane
  webhookSecret = deps.webhookSecret ?? null
  redisClient = deps.redis ?? null
}

// Redis-backed settings store
const SETTINGS_KEY = 'zenova:settings'
const REPOS_KEY = 'zenova:project-repos'

async function getSetting(key: string): Promise<string> {
  if (!redisClient) return process.env[key] ?? ''
  const val = await redisClient.hget(SETTINGS_KEY, key)
  return val ?? process.env[key] ?? ''
}

async function getAllSettings(): Promise<Record<string, string>> {
  if (!redisClient) return {}
  const all = await redisClient.hgetall(SETTINGS_KEY)
  return all ?? {}
}

async function setSetting(key: string, value: string): Promise<void> {
  if (!redisClient) return
  if (value) {
    await redisClient.hset(SETTINGS_KEY, key, value)
  } else {
    await redisClient.hdel(SETTINGS_KEY, key)
  }
}

async function getRepoForProject(projectId: string): Promise<string> {
  if (!redisClient) return process.env.REPO_URL ?? ''
  const url = await redisClient.hget(REPOS_KEY, projectId)
  return url ?? await getSetting('DEFAULT_REPO_URL') ?? process.env.REPO_URL ?? ''
}

async function getAllRepos(): Promise<Record<string, string>> {
  if (!redisClient) return {}
  return await redisClient.hgetall(REPOS_KEY) ?? {}
}

async function setRepoForProject(projectId: string, url: string): Promise<void> {
  if (!redisClient) return
  if (url) {
    await redisClient.hset(REPOS_KEY, projectId, url)
  } else {
    await redisClient.hdel(REPOS_KEY, projectId)
  }
}

function verifyWebhookSignature(body: string, signature: string | null): boolean {
  if (!webhookSecret) return true
  if (!signature) return false
  const expected = createHmac('sha256', webhookSecret).update(body).digest('hex')
  try {
    return timingSafeEqual(Buffer.from(signature), Buffer.from(expected))
  } catch {
    return false
  }
}

// ============================================================
// Health & Status
// ============================================================

app.get('/health', (c) => c.json({ status: 'ok', timestamp: new Date().toISOString() }))

app.get('/status', async (c) => c.json({ running: containers?.getRunning() ?? [], queueDepth: await queue?.depth() ?? 0 }))

// ============================================================
// Admin Settings Page
// ============================================================

const ADMIN_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Zenova Agents — Settings</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#0a0a0a;color:#e5e5e5;min-height:100vh}
    .container{max-width:720px;margin:0 auto;padding:2rem 1.5rem}
    h1{font-size:1.5rem;font-weight:600;margin-bottom:.25rem;color:#fff}
    .subtitle{color:#888;margin-bottom:2rem;font-size:.875rem}
    .card{background:#161616;border:1px solid #262626;border-radius:12px;padding:1.5rem;margin-bottom:1.5rem}
    .card h2{font-size:1rem;font-weight:600;margin-bottom:1rem;color:#fff;display:flex;align-items:center;gap:.5rem}
    .badge{font-size:.65rem;padding:2px 8px;border-radius:99px;font-weight:500}
    .badge-green{background:#052e16;color:#4ade80;border:1px solid #166534}
    .badge-yellow{background:#422006;color:#fbbf24;border:1px solid #854d0e}
    .badge-red{background:#450a0a;color:#f87171;border:1px solid #991b1b}
    .field{margin-bottom:1rem}
    .field:last-child{margin-bottom:0}
    label{display:block;font-size:.8rem;font-weight:500;color:#999;margin-bottom:.35rem}
    input,select{width:100%;padding:.6rem .75rem;background:#0a0a0a;border:1px solid #333;border-radius:8px;color:#fff;font-size:.875rem;outline:none;transition:border-color .15s}
    input:focus{border-color:#3b82f6}
    input::placeholder{color:#555}
    .hint{font-size:.75rem;color:#666;margin-top:.25rem}
    .hint a{color:#60a5fa;text-decoration:none}
    .hint a:hover{text-decoration:underline}
    .btn{display:inline-flex;align-items:center;gap:.5rem;padding:.6rem 1.25rem;border-radius:8px;font-size:.875rem;font-weight:500;border:none;cursor:pointer;transition:all .15s}
    .btn-primary{background:#3b82f6;color:#fff}.btn-primary:hover{background:#2563eb}
    .btn-secondary{background:#262626;color:#e5e5e5;border:1px solid #333}.btn-secondary:hover{background:#333}
    .actions{display:flex;gap:.75rem;margin-top:1rem;justify-content:flex-end}
    .status-bar{position:fixed;bottom:0;left:0;right:0;padding:.75rem;text-align:center;font-size:.85rem;transform:translateY(100%);transition:transform .3s;z-index:50}
    .status-bar.show{transform:translateY(0)}
    .status-bar.success{background:#052e16;color:#4ade80;border-top:1px solid #166534}
    .status-bar.error{background:#450a0a;color:#f87171;border-top:1px solid #991b1b}
    .repo-row{display:flex;gap:.5rem;align-items:end;margin-bottom:.75rem}
    .repo-row input{flex:1}
    .repo-row .btn{padding:.6rem}
    .divider{height:1px;background:#262626;margin:1.25rem 0}
    .running-list{font-size:.85rem;color:#999}
    .running-list .agent{padding:.5rem 0;border-bottom:1px solid #1a1a1a;display:flex;justify-content:space-between}
    .running-list .agent:last-child{border:none}
    .running-list .agent-name{color:#fff;font-weight:500}
  </style>
</head>
<body>
<div class="container">
  <h1>Zenova Agent Hub</h1>
  <p class="subtitle">Configure API keys, repos, and manage your AI agents</p>

  <div class="card" id="status-card">
    <h2>System Status <span class="badge badge-green" id="health-badge">Healthy</span></h2>
    <div class="running-list" id="running-list">Loading...</div>
  </div>

  <div class="card">
    <h2>Claude Authentication</h2>
    <div class="field">
      <label>Claude Code OAuth Token</label>
      <input type="password" id="CLAUDE_CODE_OAUTH_TOKEN" placeholder="sk-ant-oat01-...">
      <div class="hint">
        Uses your Claude Pro/Max subscription. Get this by running <code>claude setup-token</code> in your terminal
        (<a href="https://docs.anthropic.com/en/docs/claude-code/cli-usage" target="_blank">install Claude Code CLI</a> first: <code>npm i -g @anthropic-ai/claude-code</code>).
      </div>
    </div>
    <div class="divider"></div>
    <div class="field">
      <label>Anthropic API Key (alternative — pay-per-use)</label>
      <input type="password" id="ANTHROPIC_API_KEY" placeholder="sk-ant-api03-...">
      <div class="hint">From <a href="https://console.anthropic.com/settings/keys" target="_blank">console.anthropic.com</a>. Billed separately from subscription.</div>
    </div>
  </div>

  <div class="card">
    <h2>Google Gemini</h2>
    <div class="field">
      <label>Gemini API Key</label>
      <input type="password" id="GEMINI_API_KEY" placeholder="AIza...">
      <div class="hint">For the creative agent (image generation). Get from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>.</div>
    </div>
  </div>

  <div class="card">
    <h2>GitHub</h2>
    <div class="field">
      <label>GitHub Personal Access Token</label>
      <input type="password" id="GITHUB_TOKEN" placeholder="ghp_...">
      <div class="hint">Agents use this to clone repos and create PRs. Create at <a href="https://github.com/settings/tokens?type=beta" target="_blank">github.com/settings/tokens</a> with repo access.</div>
    </div>
  </div>

  <div class="card">
    <h2>Repository Mapping</h2>
    <p class="hint" style="margin-bottom:1rem">Map each Plane project to a GitHub repo. Agents will clone and push to the correct repo per project.</p>
    <div class="field">
      <label>Default Repo URL (used when no project mapping exists)</label>
      <input type="text" id="DEFAULT_REPO_URL" placeholder="https://github.com/your-org/your-repo">
    </div>
    <div class="divider"></div>
    <label>Per-Project Repos</label>
    <div id="repo-list"></div>
    <button class="btn btn-secondary" onclick="addRepoRow()">+ Add Project Mapping</button>
  </div>

  <div class="actions">
    <button class="btn btn-primary" onclick="saveAll()">Save Settings</button>
  </div>
</div>

<div class="status-bar" id="status-bar"></div>

<script>
const SETTINGS_KEYS = ['CLAUDE_CODE_OAUTH_TOKEN','ANTHROPIC_API_KEY','GEMINI_API_KEY','GITHUB_TOKEN','DEFAULT_REPO_URL'];

async function loadSettings() {
  const res = await fetch('/admin/api/settings');
  const data = await res.json();
  for (const key of SETTINGS_KEYS) {
    const el = document.getElementById(key);
    if (el && data.settings[key]) el.value = data.settings[key];
  }
  const repoList = document.getElementById('repo-list');
  repoList.innerHTML = '';
  if (data.repos && Object.keys(data.repos).length > 0) {
    for (const [projectId, url] of Object.entries(data.repos)) {
      addRepoRow(projectId, url);
    }
  }
}

async function loadStatus() {
  try {
    const res = await fetch('/status');
    const data = await res.json();
    const badge = document.getElementById('health-badge');
    badge.textContent = 'Healthy';
    badge.className = 'badge badge-green';
    const list = document.getElementById('running-list');
    if (data.running.length === 0) {
      list.innerHTML = '<div style="color:#666">No agents running. Queue depth: ' + data.queueDepth + '</div>';
    } else {
      list.innerHTML = data.running.map(r =>
        '<div class="agent"><span class="agent-name">' + r.agentType + '</span><span>' + r.issueId + '</span></div>'
      ).join('');
    }
  } catch {
    document.getElementById('health-badge').textContent = 'Error';
    document.getElementById('health-badge').className = 'badge badge-red';
  }
}

function addRepoRow(projectId, url) {
  const div = document.createElement('div');
  div.className = 'repo-row';
  div.innerHTML = '<input type="text" placeholder="Plane Project ID" value="' + (projectId||'') + '" class="repo-project">' +
    '<input type="text" placeholder="https://github.com/org/repo" value="' + (url||'') + '" class="repo-url">' +
    '<button class="btn btn-secondary" onclick="this.parentElement.remove()">X</button>';
  document.getElementById('repo-list').appendChild(div);
}

async function saveAll() {
  const settings = {};
  for (const key of SETTINGS_KEYS) {
    const el = document.getElementById(key);
    if (el) settings[key] = el.value;
  }
  const repos = {};
  document.querySelectorAll('.repo-row').forEach(row => {
    const pid = row.querySelector('.repo-project').value.trim();
    const url = row.querySelector('.repo-url').value.trim();
    if (pid && url) repos[pid] = url;
  });
  try {
    const res = await fetch('/admin/api/settings', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ settings, repos })
    });
    const data = await res.json();
    showStatus(data.ok ? 'Settings saved!' : 'Error saving', data.ok ? 'success' : 'error');
  } catch (e) {
    showStatus('Failed to save: ' + e.message, 'error');
  }
}

function showStatus(msg, type) {
  const bar = document.getElementById('status-bar');
  bar.textContent = msg;
  bar.className = 'status-bar show ' + type;
  setTimeout(() => bar.className = 'status-bar', 3000);
}

loadSettings();
loadStatus();
setInterval(loadStatus, 10000);
</script>
</body>
</html>`

app.get('/admin', (c) => c.html(ADMIN_HTML))

app.get('/admin/api/settings', async (c) => {
  const settings = await getAllSettings()
  const masked: Record<string, string> = {}
  for (const [k, v] of Object.entries(settings)) {
    if (v && v.length > 8 && (k.includes('TOKEN') || k.includes('KEY') || k.includes('SECRET'))) {
      masked[k] = v.slice(0, 6) + '...' + v.slice(-4)
    } else {
      masked[k] = v
    }
  }
  const repos = await getAllRepos()
  return c.json({ settings: masked, repos })
})

app.post('/admin/api/settings', async (c) => {
  try {
    const body = await c.req.json()
    const { settings, repos } = body as { settings: Record<string, string>; repos: Record<string, string> }
    if (settings) {
      for (const [k, v] of Object.entries(settings)) {
        if (v && !v.includes('...')) {
          await setSetting(k, v)
        }
      }
    }
    if (repos) {
      if (redisClient) await redisClient.del(REPOS_KEY)
      for (const [projectId, url] of Object.entries(repos)) {
        await setRepoForProject(projectId, url)
      }
    }
    return c.json({ ok: true })
  } catch (err) {
    return c.json({ ok: false, error: String(err) }, 500)
  }
})

// ============================================================
// Webhook Handler
// ============================================================

app.post('/webhooks/plane', async (c) => {
  const rawBody = await c.req.text()
  const signature = c.req.header('x-plane-signature') ?? c.req.header('x-webhook-signature')

  if (!verifyWebhookSignature(rawBody, signature ?? null)) {
    return c.json({ error: 'invalid signature' }, 401)
  }

  const payload: PlaneWebhookPayload = JSON.parse(rawBody)
  console.log(`[webhook] ${payload.event}.${payload.action}`)
  if (!dispatcher || !queue || !containers) return c.json({ error: 'not initialized' }, 503)

  const match = dispatcher.shouldDispatch(payload)
  if (!match) return c.json({ skipped: true, reason: 'no matching agent' })

  const { agentConfig, priority } = match
  const task: QueuedTask = {
    id: randomUUID(), issueId: payload.data.id, projectId: payload.data.project,
    workspaceSlug: payload.data.workspace, agentType: agentConfig.name,
    priority, payload: payload.data, queuedAt: new Date().toISOString(),
  }

  if (plane) {
    try {
      await plane.addComment(
        payload.data.workspace, payload.data.project, payload.data.id,
        `Agent ${agentConfig.name} picked up this issue.`
      )
    } catch (err) {
      console.error('[plane] Failed to post comment:', err)
    }
  }

  const running = containers.getRunningCount(agentConfig.name)
  if (running >= agentConfig.maxConcurrency) {
    await queue.enqueue(task)
    console.log(`[queue] Task ${task.id} queued (${agentConfig.name} at capacity)`)
    return c.json({ queued: true, taskId: task.id })
  }

  // Build secrets from Redis settings + env fallbacks
  const repoUrl = await getRepoForProject(task.projectId)
  const secrets = {
    GITHUB_TOKEN: await getSetting('GITHUB_TOKEN') || process.env.GITHUB_TOKEN || '',
    CLAUDE_CODE_OAUTH_TOKEN: await getSetting('CLAUDE_CODE_OAUTH_TOKEN') || process.env.CLAUDE_CODE_OAUTH_TOKEN || '',
    ANTHROPIC_API_KEY: await getSetting('ANTHROPIC_API_KEY') || process.env.ANTHROPIC_API_KEY || '',
    GEMINI_API_KEY: await getSetting('GEMINI_API_KEY') || process.env.GEMINI_API_KEY || '',
    PLANE_API_URL: process.env.PLANE_API_URL ?? '',
    PLANE_API_TOKEN: process.env.PLANE_API_TOKEN ?? '',
    REPO_URL: repoUrl,
  }
  const containerId = await containers.runAgent(agentConfig, task, secrets)
  console.log(`[dispatch] Agent ${agentConfig.name} started: ${containerId}`)

  return c.json({ dispatched: true, taskId: task.id, containerId })
})

export default app

// Server startup when run directly
const isMainModule = !process.argv[1] || process.argv[1].includes('index')
if (isMainModule && process.env.NODE_ENV !== 'test') {
  const { serve } = await import('@hono/node-server')
  const { default: Dockerode } = await import('dockerode')
  const { default: Redis } = await import('ioredis')
  const { loadAgentConfigs, Dispatcher: DispatcherClass } = await import('./config.js')

  const port = parseInt(process.env.PORT || '4000')
  const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379')
  const docker = new Dockerode()
  const agents = loadAgentConfigs(process.env.AGENTS_CONFIG || './config/agents.yaml')
  const planeClient = new PlaneClient(
    process.env.PLANE_API_URL || 'http://localhost:8000',
    process.env.PLANE_API_TOKEN || ''
  )

  init({
    dispatcher: new DispatcherClass(agents),
    queue: new TaskQueue(redis),
    containers: new ContainerManager(docker),
    plane: planeClient,
    webhookSecret: process.env.WEBHOOK_SECRET,
    redis,
  })

  serve({ fetch: app.fetch, port }, () => {
    console.log(`Orchestrator listening on port ${port}`)
    console.log(`Admin panel: http://localhost:${port}/admin`)
  })
}
INDEXEOF

# -- config/agents.yaml --
RUN cat << 'EOF' > /app/config/agents.yaml
agents:
  - name: dev
    assigneeId: ""
    dockerImage: w88kko08cwkw0kc0k84kw4kg:latest
    tools: [claude-code, git, gh-cli]
    timeout: 1800
    maxConcurrency: 3
    promptFile: packages/agents/dev/prompt.md

  - name: creative
    assigneeId: ""
    dockerImage: swsw48kk004skwwssk0s800o:latest
    tools: [gemini-imagen]
    timeout: 900
    maxConcurrency: 2
    promptFile: packages/agents/creative/prompt.md

  - name: strategy
    assigneeId: ""
    dockerImage: ik048w4ckgkkoc0skog0wk4w:latest
    tools: [claude-code, git]
    timeout: 1200
    maxConcurrency: 2
    promptFile: packages/agents/strategy/prompt.md

  - name: landing
    assigneeId: ""
    dockerImage: mo80k0gs40so8oocsc08cw44:latest
    tools: [claude-code, git]
    timeout: 2400
    maxConcurrency: 2
    promptFile: packages/agents/landing/prompt.md
EOF

# ============================================================
# 2. Install dependencies
# ============================================================

RUN npm install

# ============================================================
# 3. Compile TypeScript
# ============================================================

RUN ./node_modules/.bin/tsc

# ============================================================
# 4. Clean up dev artifacts
# ============================================================

RUN rm -rf src tsconfig.json && \
    npm prune --production

# ============================================================
# 5. Runtime configuration
# ============================================================

EXPOSE 4000

ENV PORT=4000 \
    AGENTS_CONFIG=/app/config/agents.yaml \
    NODE_ENV=production

CMD ["node", "dist/index.js"]
